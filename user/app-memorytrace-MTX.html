<!DOCTYPE html>
<html lang="en" style="height:100%;margin:0;touch-action:none;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <script type="text/javascript" src="../fixed_info.js"></script>
    <script type="text/javascript" src="../connection.js"></script>
    <script type="text/javascript" src="../paho-mqtt-min.js"></script>
    <script type="text/javascript" src="../client_dne_lib.js"></script>
    <link rel="stylesheet" href="style.css">
    <title>Connecting...</title>
    <script>
        var nameMap = "";
        var currentMap = "";
        var routeFrame = 0;
        var lastFrame = 0;
        var runStatus = "";
        let conditionA = false; // condition from I/O
        let conditionB = false; // condition from runStatus

        function onConnected() {
            subscribe("0/WHISPERER/" + type_and_serial + "/app_status");
            subscribe("0/WHISPERER/" + type_and_serial + "/io12");
            subscribe("0/THOUZER_HW/" + type_and_serial + "/event/app");
            //subscribe("0/WHISPERER/" + type_and_serial + "/speedmode");
        }

        function subscribeParse(message) {
            if(message.destinationName == "0/WHISPERER/" + type_and_serial + "/app_status") {
                const from_json = JSON.parse(message.payloadString);
                if(from_json.MT_suspend != null) {
                    if(from_json.MT_suspend) {
                        document.getElementById("stop").style.backgroundColor = "#FFF100";
                        document.getElementById("stop").onclick = function(){ publishCmd('memory-cancel'); };
                    } else {
                        document.getElementById("stop").style.backgroundColor = "#FFFFFF";
                        document.getElementById("stop").onclick = function(){ publishCmd(''); };
                    }
                }
            }
            else if(message.destinationName == "0/WHISPERER/" + type_and_serial + "/io12") {
                const from_json = JSON.parse(message.payloadString);
                if(from_json.level != null) {
                    document.getElementById("IO5").style.backgroundColor = (from_json.level.charAt(6) == '1')?"#FF0000":"";
                    document.getElementById("IO4").style.backgroundColor = (from_json.level.charAt(7) == '1')?"#FFF100":"";
                    document.getElementById("IO3").style.backgroundColor = (from_json.level.charAt(8) == '1')?"#00FF00":"";
                    if(from_json.level != null && from_json.level.charAt(6) == '1' && from_json.level.charAt(8) == '1') {
                        conditionA = true;
                        const artCheckbox = document.getElementById("art"); // Check if the checkbox with id "art" is checked
                        const isArtChecked = artCheckbox.checked;
                            if (artCheckbox.checked) {
                                newAlternative();
                            }
                        } else {conditionA = false}
                }
            } else if (message.destinationName == "0/THOUZER_HW/" + type_and_serial + "/event/app") {
                const from_json = JSON.parse(message.payloadString);
                let numMap = 0;
                nameMap = from_json.data.map;
                numMap = from_json.data.listNum;
                routeFrame = from_json.data.listPos;
                lastFrame = from_json.data.listLast;
                runStatus = from_json.data.status;
                currentMap = getCurrentData(nameMap, numMap); // find the exact name of Route based on listNum
                            const epsCheckbox = document.getElementById("eps"); // Check if the checkbox with id "eps" is checked
                            const isEpsChecked = epsCheckbox.checked;
                            if (epsCheckbox.checked) {
                                setInterval(() => {
                                toggleSwitchLogic();
                                console.log("Run Status: " + runStatus + ", Toggle Switch: " + conditionB);
                                }, 1000);
                                pointStop();
                            }
                }
                document.getElementById("message").innerHTML = "THOUZER is at " + currentMap + " route, pos at " + routeFrame + " out of " + lastFrame + " frames." + "<hr>" //+ document.getElementById("message").innerHTML
        }

        function setupCheckboxBehavior() {
            art.addEventListener('change', function() {
                if (art.checked) {
                eps.checked = false;
                }
            });
            eps.addEventListener('change', function() {
                if (eps.checked) {
                art.checked = false;
                }
            });
            }

        async function newAlternative() {
                let replaceMap = "";
                let convertedMaps = document.getElementById("map").value;
                if (!conditionA) { //Confirm conditionA is true
                    console.log("ConditionA is not met.");
                    return;
                }
                    await delay(5000); //Wait for 5 seconds

                if (!conditionA) { //Confirm conditionA is still true
                    console.log("ConditionA is no longer met. Nothing happened.");
                    return;
                }
                    publishCmd('#suspend'); //Execute publishCmd('#suspend')
                    await delay(5000); //Wait for 5 seconds for the next action
                    publishCmdParam('app-memorytrace', '--map ' + nameMap + ' --rewind') // perform resume rewind function
                    checkConditionAndExecute() // wait until complete rewind
                    console.log("complete rewind");
                    console.log(convertedMaps); // retrieve the original route formula
                    let routeART = "";
                    let resultTextbox = removePreviousData(currentMap, convertedMaps) // remove the current and previous route name (OK)
                    //console.log(resultTextbox); //OK
                    loadCSVData(csvFilePath, function() { // CSV data is loaded here, You can now call the function that relies on CSVdatasetAr
                    let resultART = {
                    replaceDataInString: function(routeART, csvFilePath) {
                    // Existing code to modify finalRouteRevise
                    let dataArray = [];
                    dataArray[0] = currentMap;
                    let i, j, dataset;
                    for (i = 0; i < dataArray.length; i++) {
                        for (j = 0; j < CSVdatasetAr.length; j++) {
                            dataset = CSVdatasetAr[j];
                            dataset = dataset.map(str => str.replace(/\r/g, ''));
                            dataArray = dataArray.map(str => str.replace(/"/g, ''));
                            console.log(dataArray[0]);
                            if (dataArray[i] === dataset[0]) {
                                if (dataset[3] != null) {
                                    dataArray[i] = dataset[3]; //if dataset[3] have value
                                    break;
                                } else {
                                    console.log("No Alternative is found")
                                    return; // Exit the function here
                                }
                                break;
                            }
                        }
                    }
                    routeART = dataArray[0]
                    console.log(routeART);
                    return routeART;
                            }
                        };
                    replaceMap = resultART.replaceDataInString(routeART, csvFilePath); //change the current route during the generateRoute function (OK)
                    //console.log(replaceMap);
                    resultTextbox = replaceMap + resultTextbox // putting back the map
                    //console.log(resultTextbox);
                    document.getElementById('map').value = resultTextbox
                    //console.log("step1")
                    });        
        }

                function delay(ms) { // Helper function to delay execution
                return new Promise(resolve => setTimeout(resolve, ms));
                }

        async function pointStop() {
            while (true) {
            const rF = routeFrame/* Assign the value of routeFrame */;
            const lF = lastFrame/* Assign the value of lastFrame */;
                if (rF === 0 && !conditionB) { // lastFrame = first Frame for next route
                publishCmd('#suspend');
                break; // Exit the loop when the condition is met
            } else {
                // If the condition is not met, wait for 1 second and check again
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
            }}

        function toggleSwitchLogic() {
            if (runStatus === "run" || runStatus === "start") {
                conditionB = true;
                setTimeout(() => {
                conditionB = false;
                }, 5000);
            } else {
                conditionB = false;
            }
        }

        function getCurrentData(nameMap, numMap) {
            const nameArray = nameMap.split("+"); // Split the nameMap string into an array using "+"
            
            if (numMap >= 0 && numMap < nameArray.length) { // Check if numMap is within a valid range
                return nameArray[numMap]; // Return the element at the numMap index
            } else {
                return "Invalid listNum"; // Return an error message if listNum is out of range
            }
        }

        function removePreviousData(currentMap, convertedMaps) {
            // Find the index of the currentMap in the inputString
            const index = convertedMaps.indexOf(currentMap);

            // If the currentMap is not found, return the inputString as is
            if (index === -1) {
                return convertedMaps;
            }
            // Extract the substring starting from the currentRoute to the end
            const result = convertedMaps.substring(index + currentMap.length);
            return result;
        }
 
        async function checkConditionAndExecute() {
            if (routeFrame === 0) {
                publishCmd('');
                await delay(3000);
                publishCmdParam('app-memorytrace', '--map ' + document.getElementById('map').value) // playback route (OK)
                console.log("Finish waiting,step2");
            } else {
                setTimeout(checkConditionAndExecute, 1000); // Check the condition again in 1 second (adjust as needed)
            }
        }

        //var datasetArray = new Array(3628800); //3628800 is factorial of 10
        let n = 3628800;
        var datasetArray = new Array(n);

        // Allocate the array structure
        for (let i = 0; i < n; i++) {
            datasetArray[i] = new Array(2); // Each dataset has 2 columns
        }

        var CSVdatasetAr = [];
        var csvFilePath = "routeList.csv"; //routeList in working directory
        var resultArr = [];
        var shortestRoute;
        var shortestValue;
        var finalRoute;
        var finalRouteRevise;

        function generateRoute() {
        // Generate the optimize route from destinations input, based on all the possible routes and pick the shortest path
            let inputTextbox = document.getElementById("inputTextbox");
            let inputstring = inputTextbox.value;
            let dataArray = inputstring.split(",");

            let dataCount = dataArray.length;
            if (dataCount > 11) {
                alert("The number of data is over 11. Exiting the program.");
                return;
            }
            let outputString = dataArray.slice(1, dataArray.length - 1).join(",");
            let middlePoints = outputString;

            let startPoint = dataArray[0];
            let endPoint = dataArray[dataArray.length - 1];
            let numMiddlePoints = dataArray.length - 2;

            if (numMiddlePoints >= 1) {
                if (!validatePointName(startPoint) || !validatePointName(endPoint) || !validateMiddlePoints(middlePoints)) { 
                    alert("Invalid input. Please enter valid point names.");
                    return;
                }
            } else {
                if (!validatePointName(startPoint) || !validatePointName(endPoint)) { 
                    alert("Invalid input. Please enter valid point names.");
                    return;
                }
            }

            let middlePointArr = middlePoints.split(",");
            middlePointArr.sort();

            let routeName = startPoint;

            let j = factorial(numMiddlePoints);
            let k = 1;

            do {
                for (let i = 0; i < numMiddlePoints; i++) {
                    routeName += middlePointArr[i] + "+" + middlePointArr[i];
                }

                var FirstData = routeName + endPoint;
                if (k < (j + 1)) {
                    datasetArray[k-1][0] = [FirstData];
                    k++;
                }

                routeName = startPoint;

            } while (numMiddlePoints > 1 && generateNextPermutation(middlePointArr));

            //console.log(datasetArray); // This will log the CSV data as an array of arrays (rows and columns)
            loadCSVData(csvFilePath, function() { // CSV data is loaded here, You can now call the function that relies on CSVdatasetAr

                if (numMiddlePoints > 1) {
                resultArr = getLowestValueAndShortestRoute();
                shortestRoute = resultArr[0];
                shortestValue = resultArr[1];
                finalRoute = shortestRoute;
                } else {
                    sValue = datasetArray[0][1];
                    sRoute = datasetArray[0][0];
                    resultLS = [sRoute, sValue];
                    resultArr = resultLS;
                    shortestRoute = resultArr[0];
                    finalRoute = shortestRoute;
                }

                let routeModifier = {
                    replaceDataInString: function(finalRouteRevise, csvFilePath) {
                    // Existing code to modify finalRouteRevise
                    finalRoute = finalRoute.map(str => str.replace(/\r/g, ""));
                    let objectAsString = JSON.stringify(finalRoute[0]);
                    let dataArray = objectAsString.split('+');
                    //console.log(objectAsString);
                    //console.log(dataArray);
                    let i, j, dataset;
                    for (i = 0; i < dataArray.length; i++) {
                        let valueNotFound = true; // Initialize a flag variable
                        for (j = 0; j < CSVdatasetAr.length; j++) {
                            dataset = CSVdatasetAr[j];
                            dataset = dataset.map(str => str.replace(/\r/g, ''));
                            dataArray = dataArray.map(str => str.replace(/"/g, ''));
                            //console.log(dataset);
                            if (dataArray[i] === dataset[0]) {
                                dataArray[i] = dataset[2];
                                valueNotFound = false;
                                break;
                            }   
                        } 
                        // Check the flag after the inner loop
                        if (valueNotFound) {
                            alert(dataArray[i]+" route is not found in preset list.");
                            //alert('Value not found: ' + dataArray[i]); // You can choose to break or handle this case as needed
                            return;
                        }}

                    finalRouteRevise = dataArray.join("+");
                    // Remove double quotation marks from the value
                    finalRouteRevise = finalRouteRevise.replace(/"/g, '');
                    console.log(finalRouteRevise);
                    return finalRouteRevise;
                            }
                        };

                let modifiedValue = routeModifier.replaceDataInString(finalRoute, csvFilePath); // Call the method and get the modified value
                //console.log(modifiedValue); // Use the modified value
                let resultTextbox = document.getElementById("map"); // Set the value of the resultTextbox
                if (resultTextbox) {
                if (typeof modifiedValue !== "undefined") {
                    resultTextbox.value = modifiedValue;
                } else {
                    console.log("Modified value is undefined.");
                    resultTextbox.value = "";
                }
                } else {
                    console.log("Element with ID 'map' not found.");
                }
            });
        }

        function generateNextPermutation(arr) {
            let i, j, k;

            if (arr.length < 2) {
                return false;
            }

            i = arr.length - 2;
            while (arr[i] >= arr[i + 1]) {
                if (i === 0) return false;
                i--;
            }

            j = arr.length - 1;
            while (arr[j] <= arr[i]) {
                j--;
            }

            swap(arr, i, j);

            k = i + 1;
            j = arr.length - 1;
            while (k < j) {
                swap(arr, k, j);
                k++;
                j--;
            }

            return true;
        }

        function swap(arr, a, b) {
            let temp = arr[a];
            arr[a] = arr[b];
            arr[b] = temp;
        }

        function validatePointName(pointName) {
            return /^[A-Z]$/.test(pointName); // Only allow single CAPITAL letter alphabet
        }

        function validateMiddlePoints(middlePoints) {
            let pointArr = middlePoints.split(",");
            for (let i = 0; i < pointArr.length; i++) {
                if (!validatePointName(pointArr[i].trim())) {
                    return false;
                }
            }
            return true;
        }

        function factorial(n) {
            if (n <= 1) {
                return 1;
            } else {
                return n * factorial(n - 1);
            }
        }

        function loadCSVData(csvFilePath, callback) {
            let xhr = new XMLHttpRequest();
            xhr.open("GET", csvFilePath, true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    let fileContent = xhr.responseText;
                    let dataArray = fileContent.split('\n');
                    CSVdatasetAr = dataArray.map(function(line) {
                        return line.split(',');
                    });
                    callback(CSVdatasetAr);
                }
            };
            xhr.send();
        }

        function getLowestValueAndShortestRoute() {
            const nonEmptyCount = datasetArray.filter(dataset => dataset.some(item => item !== undefined && item !== null && item !== '')).length;
            //console.log(nonEmptyCount); //Confirmation
            
            for (let i = 0; i < nonEmptyCount; i++) {
                let objectAsString = JSON.stringify(datasetArray[i][0]);
                let dataParts = objectAsString.split('+');
                let sumValue = 0;

                for (let k = 0; k < dataParts.length; k++) {
                    for (let j = 0; j < CSVdatasetAr.length; j++) {
                        if (CSVdatasetAr[j][0] === dataParts[k]) {
                            sumValue += parseFloat(CSVdatasetAr[j][1]);
                            break; // Exit the loop once a match is found
                        }
                    }
                }
                datasetArray[i][1] = sumValue;
            }

            var sValue = 0; // Initialize with 0 (if no non-zero value is found)
            var sRoute = '';
            var foundNonZero = false;

            for (let i = 0; i < datasetArray.length; i++) {
                if (datasetArray[i][1] !== 0) {
                    if (!foundNonZero || datasetArray[i][1] < sValue) {
                        sValue = datasetArray[i][1];
                        sRoute = datasetArray[i][0];
                        foundNonZero = true;
                    }
                }
            }
            // Return the result as an array
            var resultLS = [sRoute, sValue];
            return resultLS;
        }

        function clearInput() {
            let inputTextbox = document.getElementById("inputTextbox");
            inputTextbox.value = ""; // Set the input field value to an empty string
            
            let resultTextbox = document.getElementById("map");
            resultTextbox.value = ""; // Clear the resultTextbox value
        }
        window.addEventListener('DOMContentLoaded', setupCheckboxBehavior); // Check checkbox conflict

    </script>
</head>
<body style="height:100%;margin:0;" onload="tryConnectFirst();">
    <div id="status" class="area" style="height:8%;font-size:7vmin;">Connecting...</div>
    <div class="area" style="height:10%;font-size:5vmin;width:33%;position:relative;border:2px solid #232323;" id="IO5"><span class="text">IO5-Red</span></div>
    <div class="area" style="height:10%;font-size:5vmin;width:33%;position:relative;border:2px solid #232323;" id="IO4"><span class="text">IO4-Yellow</span></div>
    <div class="area" style="height:10%;font-size:5vmin;width:33%;position:relative;border:2px solid #232323;" id="IO3"><span class="text">IO3-Green</span></div>
    <div style="clear:both;"></div>
    
    <!--<div>
    <label for="inputTextbox">THE FIRST POINT IS START POINT AND THE LAST POINT IS END POINT</label><br>
    <label for="inputTextbox">ALL MIDDLES POINTS CAN BE INPUT IN RANDOM MANNER</label><br><br>
    <label for="inputTextbox">MAXIMUM DESTINATION LIMIT IS 10</label><br><br>
    </div>-->
    
    <input id="inputTextbox" type="text" style="height:10%;font-size:4vmin;width:calc(100% - 25px);box-sizing:border-box;" placeholder="Insert the destinations here in alphabet (e.g., A,B,C,D,E)">
    
    <div class="area" style="height:15%;;width:55%;font-size:7vmin;"><div class="button" onclick="generateRoute()" id="gRoute"><span class="text">route finder</span></div></div>
    <div class="area" style="height:15%;;width:44%;font-size:7vmin;"><div class="button" onclick="clearInput()" id="cInput"><span class="text">clear all</span></div></div>

    <input id="map" type="text" style="height:10%;font-size:4vmin;width:calc(100% - 25px);box-sizing:border-box;" placeholder="">
    <div class="area" style="height:15%;font-size:10vmin;width:44%;"><div class="button" onclick="publishCmdParam('app-memorytrace', '--map ' + document.getElementById('map').value + (document.getElementById('loop').checked?' --loop':'') + (document.getElementById('reverse').checked?' --reverse':''))"><span class="text">Play</span></div></div>
    <div class="area" style="height:15%;font-size:10vmin;width:55%;"><div class="button" onclick="publishCmd('')" id="stop"><span class="text">Stop</span></div></div>

    <div class="area" style="height:7%;width:20%;"><input type="checkbox" id="loop" name="loop"><label for="loop" style="font-size:4vmin;"> loop</label></div>
    <div class="area" style="height:7%;width:25%;"><input type="checkbox" id="reverse" name="reverse"><label for="reverse" style="font-size:4vmin;"> reverse</label></div>
    <div class="area" style="height:7%;width:20%;"><input type="checkbox" id="art" name="art"><label for="art" style="font-size:4vmin;"> ART</label></div>
    <div class="area" style="height:7%;width:20%;"><input type="checkbox" id="eps" name="eps"><label for="eps" style="font-size:4vmin;"> EPS</label></div><br><br>
    <div class="area" style="clear:both; height: 0;"></div> <!-- Add this line to clear any previous floating elements -->

    <div class="area" style="height:15%;font-size:7vmin;width:49%;"><div class="button" onclick="publishCmd('#pause')"><span class="text">#pause</span></div></div>
    <div class="area" style="height:15%;font-size:7vmin;width:49%;"><div class="button" onclick="publishCmd('#run')"><span class="text">#run</span></div></div>

    <div id="message" style="overflow-y:scroll;font-size:4vmin;width:calc(100% - 25px);"><br></div> <!--Please push button.<br><br>INVISIBLE default subscribed topic.<br> 0/WHISPERER/+/version <input id="visible" type="checkbox">visible</check></div>-->
</body>
</html>
